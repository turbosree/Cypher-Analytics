The goal of this project is to develop a Cryptographic Toolkit for common applications of cryptography techniques in distributed embedded control systems.

1) Stream ciphers:
-----------------
EXP[1] Danger with many time pad stream cipher: Problem with using the same stream cypher key multiple times. 
- CypherText.py: This script will help you to generate keys and cypher texts
- CryptoUtils.py: This script will provide you tools and experiments to analyse the cypher. 

EXP[2] Brute-force attack or exhaustive key search: Analyze a weak PRG whose output can be predicted in roughly 2^28 time.
- WeakPRG.py: With random seeds, each 28 bits, this algorithm will output 9 psuedo-random numbers.
- BreakPRG.py: This experiment will predict it's 10th output in roughly 2^28 time.

2) Block ciphers:
-----------------
EXP[3] Generic birthday attack - SHA-256 case study: Collision resistence is necesary for security (Message Integrity)
Let H:M→{0,1}^n be a hash function (|M| >> 2^n). There is an algorithm to find a collision in time O(2^(n/2)) hashes.

- GenericBirthDayAttack.py: Consider the hash function obtained by truncating the output of SHA-256 to 50 bits, say H(x)=LSB50(SHA256(x)), that is we drop all but the right most 50 bits of the output. Our goal is to implement a generic birthday attack to find a collision on this hash function. Find two strings x≠y such that LSB50(SHA256(x))=LSB50(SHA256(y)).

EXP[4] Meet in the middle attack: Compute discrete log modulo a prime p.
Let g be some element in Zp* (Set of invertible evlements in Zp = {0,1,2...,p-1}) and suppose we are given h in Zp∗ 
such that h=g^x where 1≤x≤2^40. Our goal is to find x! We will use meet in the middle attack to find x.
Let B=2^20. Since x is less than B2 we can write the unknown x base B as x=x0*B+x1 where x0,x1 are in the range [0,B−1]. 
Then,
   h=g^x=g^(x0*B+x1)=(g^B)^x0 * g^x1 in Zp.
By moving the term g^x1 to the other side we obtain,
   h/g^x1=(g^B)^x0 in Zp. From this equality, we can find (x0,x1) such that there is a collision between LHS and RHS.

- mod_arithm.py:
 *  First build a hash table of all possible values of the left hand side h/g^x1 for x1=0,1,…,2^20.
 *  Then for each value x0=0,1,2,…,2^20 check if the right hand side (g^B)^x0 is in this hash table.
 *  If a collision is found, then x = x0*B+x1
To do modular arithmatic with large numbers, we will use gmpy.

3) Sample application to generate Key diversification test vectors conforming to NXP application note AN10922:
--------------------------------------------------------------------------------------------------------------
Refer section: 2.2.1 AES-128 key diversification example in NXP application note AN10922.
https://www.nxp.com/docs/en/application-note/AN10922.pdf

4) Sample application to generate ECDSA signature test vectors for given inputs that conform to FIPS 186-4: Digital Signature Standard:
---------------------------------------------------------------------------------------------------------------------------------------
The signature uses ECDSA with SHA-256 and curve point NIST P-256 as specified in 'FIPS 186-4: Digital Signature Standard'. 

Reference section: 3.3 Digital Signature Verification and Validation in FIPS 186-4: Digital Signature Standard.
https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf

5) An implementation of Shamir's Secret Sharing scheme for distributed embedded systems. The test application generates fragements of a secret (Eg: AES128 Key) 
for the purpose of distributing it in a distributed embedded control system. TODO: Secure storage and trasport of secret cryptographic materials.

Reference:
https://github.com/twhiteman/pyDes
https://en.wikipedia.org/wiki/Shamir%27s_Secret_Sharing
https://en.wikipedia.org/wiki/Key_checksum_value

6) An implementation of generic software based cryptographic endorsement and attestation mechanism for distributed embedded systems. 
The test application uses a combination of assymetric and symmetric cryptography techniques to establish an end-to-end verifiable trust between any 2 independent 
entities in a distributed system. This also has applications in privacy by design patterns.

Reference:
https://en.wikipedia.org/wiki/Trusted_Platform_Module#Endorsement_keys
https://en.wikipedia.org/wiki/Direct_Anonymous_Attestation

7) A test Root CA to generate X509 certificates. The attestation and edorsement applications described in (6) can read, describe and make use of the certificates 
in the cryptographic operations.

Referecene:
https://en.wikipedia.org/wiki/Root_certificate

8) Dynamic QR Code based on dynamic URL generated using SHA256 hash, ECDSA signature and timestamp

Reference:
https://en.wikipedia.org/wiki/QR_code
https://en.wikipedia.org/wiki/URL
https://qrdate.org/

9) Standard browsers and http libraries (curl, pthon requests etc.) do not send URL Fragments (part of URL that comes after #) to server. But by intercepting the URL, 
an attacker can convert the URL fragment to URL query string and force the browser or library to send the information in fragment to the Server. In many cases the fragment
contains security tokens, personally identifiable IDs and sensitive information which are not intended to be send to the server. Depending upon the criticality of 
information leaked, such exploitations can lead to privacy issues.

Reference: 
https://curl.se/mail/lib-2011-11/0178.html
https://what.thedailywtf.com/topic/19087/uri-fragment-sent-to-server/12

10) Dynamic QR Code based on dynamic URL generated using TOTP (Time-based one-time password)

Reference:
https://en.wikipedia.org/wiki/Time-based_one-time_password

11) Dynamic QR Code based on dynamic URL generated using JWT(JSON_Web_Token)

Reference:
https://en.wikipedia.org/wiki/JSON_Web_Token

12) Secure UUID (A universally unique identifier) generator from X509 certificate

Reference:
https://en.wikipedia.org/wiki/Universally_unique_identifier
